type list<'a> = Nil of unit | Cons of 'a * list<'a>

letw fixw = fun x ->
  case x of 
    Inl(lx) -> 
      let (l,x) = lx in
        (case x of
           Inl(bq) ->
             let (b,q) = bq in
               Inl(Cons(b,l), Inr(q))
         | Inr(a) ->
             (delete l of (* TODO *)
                Nil -> Inr(a)
              | Cons(hdtl) ->
                 let (hd, tl) = hdtl in
                   Inl(tl, Inl(hd, a))))
  | Inr(q) -> 
     Inl(Nil, Inr(q))

letu fix = hack fixw
 as {list<'b>}({'b}'a --o 'a) --o 'a

(* Tail recursion looks much nicer than loops ;) *)
letw tailrecw = fun x ->
  case x of 
    Inr(q) ->
     (case q of
        Inr(u) -> Inr(Inl((), ()))
      | Inl(ua) ->
         let (u, a) = ua in
            Inl(a, Inr(Inr())))
  | Inl(a_s) ->
    let (a, s) = a_s in
      (case s of
         Inr(r) -> 
          (case r of
              Inr(b) -> Inr(Inr(b))
            | Inl(cu) ->
                let (c, u) = cu in
                  Inl(a, Inr(Inl(c, a))))
       | Inl(dp) ->
          let (d, p) = dp in
            (case p of
               Inr(u) -> Inl(a, Inl(d, Inl((), ())))
             | Inl(ua) ->
                let (u, a) = ua in
                  Inl(a, Inr(Inr())))
      )

letu tailrec = hack tailrecw
 as {'a}({'d}({unit}['a] --o ['b]) --o ({'c}['a] --o ['b])) --o {unit}['a] --o ['b]

letw coroutw = fun x ->
  case x of 
    Inl(l) ->
      let (l1, l2) = l in
        (case l2 of
          Inl(l2l) -> 
           let (l2l1, l2l2) = l2l in
             (case l2l2 of
               Inl(l2l2l) ->
                 let (u, l2l2l) = l2l2l in
                 (case l1 of 
                   Inl(l1l) -> Inr(Inl((l2l1, l2l2l), Inr(Inr())))
                 | Inr(l1r) -> 
                    let (l1r1, l1r2) = l1r in
                      Inr(Inl((l2l1, l2l2l), Inl(l1r1, Inr(l2l2l)))))
             | Inr(l2l2r) -> Inl(l1, Inl(l2l1,Inl((), ()))))
        | Inr(l2r) -> Inr(Inr(l2r)))
  | Inr(r) -> 
      (case r of 
        Inl(rl) ->
          let (rl1, rl2) = rl in
            (case rl2 of
              Inl(rl2l) -> 
               let (rl2l1, rl2l2) = rl2l in
                 (case rl2l2 of
                   Inl(rl2l2l) -> 
                     let (u, rl2l2l) = rl2l2l in
                     let (rl11, rl12) = rl1 in
                       Inl(Inr(rl2l1, rl2l2l), Inl(rl11, Inr(rl2l2l)))
                 | Inr(rl2l2r) -> Inr(Inl(rl1, Inl(rl2l1, Inl((), ())))))
            | Inr(rl2r) -> 
                case rl2r of
                  Inl(rl2rl) ->  
                    let (rl11, rl12) = rl1 in
                    let (rl2rl1, rl2rl2) = rl2rl in
                      Inr(Inl(rl1, Inr(Inl(rl2rl1, rl12))))
                | Inr(rl2rr) -> Inr(Inr(rl2rr)))
      | Inr(rr) -> Inl(Inl(), Inr()))

letu corout = hack coroutw
 as {unit+'e*'b}({'d}({unit}['a] --o ['b]) --o ['c]) --o 
    {'d*'a}({'e}({unit}['b] --o ['a]) --o {'f}['a] --o ['c]) --o ['c]

(*
letu t0 =
   tailrec (fun f -> fun x->
         let [x1] = x in
         let [u] = [print "a: "] in
         let [u] = [print x1] in
         let [u] = [print "\n"] in
           f [x1+1])
*)

letu main = corout 
   (fun defer ->
    tailrec (fun (f : [int] --> [int]) -> 
     fun x ->
      let [v] = x in
      let [x1] = if v = (v/2)*2 then defer [v + 1] else [v+1] in
      let [u] = [print "a: "] in
      let [u] = [print x1] in
      let [u] = [print "\n"] in
        f [x1]) 
      [0])
   (fun defer -> fun x ->
    let [u] = [print "b: start\n"] in
    tailrec (fun f -> fun x ->
      let [v] = x in
      let [x1] = defer [v + 2] in
      let [u] = [print "b: "] in
      let [u] = [print x1] in
      let [u] = [print "\n"] in
        f [x1]) x)

letu callcc = hack fun x -> 
  case x of 
    Inl(y) ->
      let (ys, yv) = y in
        (case yv of
          Inl(z) -> 
            let (zs, zv) = z in
              (case zv of
                Inl(u) -> 
                  let (us, uv) = u in
                    Inr(uv)
              | Inr(v) ->
                    Inl(ys, Inl(zs, Inl((), ()))))
        | Inr(a) -> Inr(a))
  | Inr(q) -> Inl((), Inr())
  as {'e}({'c}({'f}['a] --o ['d]) --o ['a]) --o ['a]
(*
Seems like we can't do the following without grabc/callc, 
as callcc cannot return continuation. 

(define r1
  (lambda (cont)
    (display "I'm in r1!")
    (newline)
    (r1 (call/cc cont))))

(define r2
  (lambda (cont2)
    (display "I'm in r2!")
    (newline)
    (r2 (call/cc cont2))))

letu t21 = 
   (fix (fun t21 -> fun k ->
      let [u] = [print "b: "] in
        t21 (callcc k) 
        ))
letu t22 =        
   (fun k ->
    loop2 [()] (fun x ->
      let [v] = x in
      let [x1] = callcc k in
        [Loop ()]))
*)
(*
    (fun pass -> fun x ->
    let [u] = [print "b: start\n"] in
    let [v] = x in
    fix (fun f -> fun x -> 
      let [v] = x in
      let [x1] = pass [v + 2 ] in
      let [u] = [print "b: "] in
      let [u] = [print x1] in
      let [u] = [print "\n"] in
        f [x1]) [v])
*)        

(*        
        (fun pass -> fun v -> 
    copy pass as pass1, pass2 in
    let [x] = v in
    let [u] = [print "b: "] in
    let [u] = [print x] in
    let [u] = [print "\n"] in
    let [x1] = pass1 [x + 1] in
    let [u] = [print "b: "] in
    let [u] = [print x1] in
    let [u] = [print "\n"] in
    let [x1] = pass2 [x1 * 15] in
    [()]
    )*)
