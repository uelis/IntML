type list<'a> = Nil of unit | Cons of 'a * list<'a>

 letw fixw = fun x ->
   case x of 
    Inl(lx) -> 
      let (l,x) = lx in
        (case x of
           Inl(bq) ->
             let (b,q) = bq in
               Inl(Cons(b,l), Inr(q))
         | Inr(a) ->
             (delete l of 
                Nil -> Inr(a)
              | Cons(hdtl) ->
                 let (hd, tl) = hdtl in
                   Inl(tl, Inl(hd, a))))
  | Inr(q) -> 
     Inl(Nil, Inr(q))
 
 letu fix = hack fixw
 as {list<'b>}({'b}'a --o 'a) --o 'a
 
letu cons : [int] --> ([int] --> [int]) --> ([int] --> [int]) =  
  fun x -> fun xs ->
      fun i -> 
        let [iv] = i in
        if iv = 0 then x else xs [iv - 1]
 
letu head =
  fun l -> l [0]
 
letu tail =
   fun l -> 
     fun i-> l (let [iv] = i in [iv+1])

letu andalso : [bool] --> [bool] --> [bool] =
  fun x -> fun y ->
    let [b] = x in
      if b then y else [False]

letu orelse : [bool] --> [bool] --> [bool] =
  fun x -> fun y ->
    let [b] = x in
      if b then [True] else y

letu printlist =
  fun l ->
  fun j ->
  let [jv] = j in
  fix (fun p -> 
         fun i ->
            let [iv] = i in
            if (iv = jv) then [()]
            else
                let [xv] = l [iv] in 
                let [u] = [print xv] in
                let [u] = [if iv + 1 < jv then print " " else ()] in
                  p [iv + 1]) [0]

letw signum = fun x -> if 0 < x then 1 else if x = 0 then 0 else 0-1
letw abs = fun x -> if 0 < x then x else 0-x
 
 letu aux =
  fix (fun aux ->
         fun n ->
           copy n as n1, n2 in
             cons [1] (cons n1 (cons [1] (aux (let [nv] = n2 in [nv + 2])))))

letu eContFrac = cons [2] (aux [2])             

letu ratTrans =
  (fix (fun ratTrans ->
          fun a -> fun b -> fun c -> fun d -> fun xs ->
          fun i ->
             let [av] = a in
             let [bv] = b in
             let [cv] = c in
             let [dv] = d in
             let [iv] = i in
            let [c] = 
              andalso 
                (orelse [signum cv = signum dv] [abs cv < abs dv])
                (andalso [(cv+dv)*(bv/dv) < av+bv+1]
                         [av+bv < (cv+dv)*(bv/dv) + (cv+dv)]) in
            if c then
                  (if iv = 0 then [bv/dv]
                   else ratTrans [cv] [dv] [av-(bv/dv)*cv] [bv-(bv/dv)*dv] xs [iv-1])
            else 
                  copy xs as xs1, xs2 in
                  let [xv] = xs1 [0] in
                   ratTrans [bv] [av+xv*bv] [dv] [cv+xv*dv] (tail xs2) [iv]
  ))

letu toDigits = 
   fix (fun toDigits ->
          fun l ->
           fun i ->
             let [iv] = i in
             if iv = 0 then l [iv] else
               toDigits (ratTrans [10] [0] [0] [1] (tail l)) [iv-1])

letu e = (toDigits eContFrac)
 
letu main = printlist e [10]
