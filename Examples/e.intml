letw return = fun x -> inl(x)
letw continue = fun x -> inr(x)

letw fixw = fun x ->
  case x of 
    inl(lx) -> 
      let <l,x> = lx in
        case x of
          inl(bq) ->
            let <b,q> = bq in
              inl(<fold<'c.1+'b*'c> inr(<b,l>), inr(q)>)
        | inr(a) ->
            case unfold<'c.1+'b*'c> l of
              inl(nl) -> 
                 inr(a)
            | inr(cns) ->
               let <hd, tl> = cns in
                 inl(<tl, inl(<hd, a>)>)
  | inr(q) -> 
     inl(<fold<'c.1+'b*'c> inl(<>), inr(q)>)

letu fix = hack fixw
 as {mu 'c. 1 + 'b*'c}({'b}'a --o 'a) --o 'a

  (*
{mu 'x. 1 + 'a*'b*'x}({'z}({'y}['a] --o ['b]) --o 'u) --o
{(mu 'x. 1 + 'a*'b*'x) * 'z}({'y}['a] --o ['b]) --o 'u
  *)

letu cons : [int] --> ([int] --> [int]) --> ([int] --> [int]) =  
  fun x -> fun xs ->
      fun i -> 
        let [iv] = i in
        case iv = 0 of
           inl(tt) -> x
         | inr(ff) -> xs [iv - 1]

letu head =
  fun l -> l [0]

letu tail = 
  fun l -> 
     fun i-> l (let [iv] = i in [iv+1])

letu printlist =
  fun l ->
  fun j ->
  let [jv] = j in
  fix (fun p -> 
         fun i ->
           let [iv] = i in
           case iv = jv of
              inl(tt) -> [<>]
            | inr(ff) -> 
                let [xv] = l [iv] in 
                let [u] = [print xv] in
                let [u] = [print ""] in
                  p [iv + 1]) [0]

letu aux =
  fix (fun aux ->
         fun n ->
           copy n as n1, n2 in
             cons [1] (cons n1 (cons [1] (aux (let [nv] = n2 in [nv + 2])))))

letu eContFrac = cons [2] (aux [2])             

letw signum = fun x -> if x < 0 then 0-1 else if x = 0 then 0 else 1
letw abs = fun x -> if x < 0 then 0-x else x
letw true : 2 = inl(<>)
letw false : 2 = inr(<>)
letw not : 2 -> 2 =
  fun x -> if x then false else true
letw and : 2 -> 2 -> 2 = 
  fun x -> fun y ->
    if x then y else false
letw or = fun (x : 2) -> fun (y : 2) ->
  if x then true else y

letu ratTrans =
   fix (fun ratTrans ->
          fun a -> fun b -> fun c -> fun d -> fun xs ->
           fun i ->
             let [av] = a in
             let [bv] = b in
             let [cv] = c in
             let [dv] = d in
             let [iv] = i in
             let [qv] = [if dv = 0 then 1 else bv/dv] in
             case and (or (signum cv = signum dv) (abs cv < abs dv)) 
                      (and ((cv+dv)*qv < av+bv+1) 
                           (av+bv < (cv+dv)*qv + (cv+dv))) of
                inl(tt) ->
                   case iv = 0 of
                      inl(tt) -> [qv]
                    | inr(ff) -> ratTrans [cv] [dv] [av-qv*cv] [bv-qv*dv] xs [iv-1]
              | inr(ff) ->
                   copy xs as xs1, xs2 in
                   let [xv] = xs1 [0] in
                    ratTrans [bv] [av+xv*bv] [dv] [cv+xv*dv] (tail xs2) [iv]
   )

letu toDigits = 
   fix (fun toDigits ->
          fun l ->
            fun i ->
              let [iv] = i in
              case iv = 0 of
                 inl(tt) -> l [iv]
               | inr(ff) -> toDigits (ratTrans [10] [0] [0] [1] (tail l)) [iv-1])

letu e = toDigits eContFrac

letu ttt = printlist e [11]
