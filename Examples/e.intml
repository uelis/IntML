letw return = fun x -> Inl(x)
letw continue = fun x -> Inr(x)

type list<'a> = Nil of unit | Cons of 'a * list<'a>

letw fixw = fun x ->
  case x of 
    Inl(lx) -> 
      let (l,x) = lx in
        (case x of
           Inl(bq) ->
             let (b,q) = bq in
               Inl(Cons(b,l), Inr(q))
         | Inr(a) ->
(*            let r = unfold<'c.unit+'b*'c> l in
            let u = delete<'c.unit+'b*'c> l in *)
             (case l of (* TODO *)
                Nil -> Inr(a)
              | Cons(hdtl) ->
                 let (hd, tl) = hdtl in
                   Inl(tl, Inl(hd, a))))
  | Inr(q) -> 
     Inl(Nil, Inr(q))

letu fix = hack fixw
 as {list<'b>}({'b}'a --o 'a) --o 'a

(*
letw fixw = fun x ->
  case x of 
    Inl(lx) -> 
      let (l,x) = lx in
       (case x of
          Inl(bq) ->
            let (b,q) = bq in
              Inl(fold<'c.unit+'b*'c> (Inr(b,l)), Inr(q))
        | Inr(a) ->
            let r = unfold<'c.unit+'b*'c> l in
            let u = delete<'c.unit+'b*'c> l in  
            (case r of
              Inl(nl) -> 
                 Inr(a)
            | Inr(cns) ->
               let (hd, tl) = cns in
                 Inl(tl, Inl(hd, a)) ))
  | Inr(q) -> 
     Inl(fold<'c.unit+'b*'c> (Inl()), Inr(q))

letu fix = hack fixw
 as {'c (* mu 'c. 1 + 'b*'c *)}({'b}'a --o 'a) --o 'a
*)
(*
type lazylist<'a> = 
        Susp of cont<cont<'a>>
      | Cons of (cont<cont<'a>> + int) * lazylist<'a>
*)
letw susp = fun x -> 
      fold<'a. cont<cont<'a>> + (cont<cont<int>> + int) * 'a> Inl(x)
letw ccons = fun x -> 
      fold<'a. cont<cont<'a>> + (cont<cont<int>> + int) * 'a> Inr(x)

(* Invariante: Wenn man Inl(k) einmal forced, dann kommt nicht wieder
 * eine Liste der Form Inl(...) heraus *)
letu cons : [int] --> [mu 'a. cont<cont<'a>> + (cont<cont<int>> + int) * 'a]
                  --> [mu 'a. cont<cont<'a>> + (cont<cont<int>> + int) * 'a] =  
  (fun x -> fun xs ->
    let [xk] = suspend(x) in
    let [xsk] = suspend(xs) in
    let [id] = 
           [ ccons(Inl(xk), susp(xsk)) ] in
        [id])

letu ft = 
  fun l -> 
    let [lid] = l in
    case unfold<'a. cont<cont<'a>> + (cont<cont<int>> + int) * 'a> lid of
      Inl(thunk) -> 
        let [v] = force thunk in
        let [u] = [ lid :=<'a. cont<cont<'a>> + (cont<cont<int>> + int) * 'a> 
                         unfold<'a.cont<cont<'a>> + (cont<cont<int>> + int) * 'a> v ] in
          [lid]
    | Inr(v) -> [lid]

letu head =
  fun l -> 
    let [lid] = ft l in
    case unfold<'a. cont<cont<'a>> + (cont<cont<int>> + int) * 'a> lid of
      Inl(thunk) -> 
        [let x=0 loop Inr(x)]
    | Inr(ht) ->
        case let (h,t) = ht in h of
          Inl(k) -> 
            let [v] = force k in
            let [u] = [  let (h,t) = ht in
                         lid :=<'a. cont<cont<'a>> + (cont<cont<int>> + int) * 'a> Inr(Inr(v), t) ] in
              [v]
        | Inr(v) -> 
              [v]

letu tail =
  fun l -> 
    let [lid] = ft l in
    case unfold<'a. cont<cont<'a>> + (cont<cont<int>> + int) * 'a> lid of
      Inl(thunk) -> 
        [let x=0 loop Inr(x)]
    | Inr(ht) ->
        [let (h,t) = ht in t]

letu thunk =
  fun l -> 
    (* Invariante erhalten *)
    let [thunk] =  suspend (ft l) in
      [ susp(thunk) ]
    
letu zipWith = fun f -> 
  fix (fun zw -> fun l1 -> fun l2 ->
     let [v1] = l1 in
     let [v2] = l2 in
       cons (f (head [v1]) (head [v2])) (zw (tail [v1]) (tail [v2])))

letu fib =
  (fix ( (fun f ->
       let [v] = thunk f in
       cons [0] (cons [1] (zipWith (fun x -> fun y -> 
                                      let [xv] = x in
                                      let [yv] = y in [xv+yv])
                               [v] (tail [v])) ))))

(* loop im Compiler!
letu cycle =
  (fix (fun cycle -> fun n -> cons [1] (cycle n)))
*)

letu cycle =
  (fix (fun cycle -> cons [1] cycle))

letu printlist =
  fun l ->
  fun j ->
  let [jv] = j in
  fix (fun p -> 
         fun i ->
         fun l -> 
           let [iv] = i in
           if iv = jv then [()] 
             else
                let [lid] = l in 
                let [xv] = head [lid] in
                let [u] = [print xv] in
          (*      let [u] = [if iv + 1 < jv then print ", " else ()] in *)
                  p [iv + 1] (tail [lid])) 
    [0] l

letu aux =
  fix (fun aux -> fun n ->
           let [nv] = n in
             cons [1] (cons [nv] (cons [1] (aux [nv + 2]))))

letu eContFrac =  (cons [2] (aux [2]))

letw signum = fun x -> if 0 < x then 1 else if x = 0 then 0 else 0-1
letw abs = fun x -> if 0 < x then x else 0-x

type bool = True of unit | False of unit

letw not : bool -> bool =
  fun x -> case x of True -> False | False -> True
letw and : bool -> bool -> bool =
  fun x -> fun y ->
    case x of True -> y | False -> False
letw or = fun (x : bool) -> fun (y : bool) ->
  case x of True -> True | False -> y

letu ratTrans =
   (fix ((fun ratTrans ->
          fun a -> fun b -> fun c -> fun d -> fun xs ->
             let [av] = a in
             let [bv] = b in
             let [cv] = c in
             let [dv] = d in
             let [qv] = [if dv = 0 then 1 else bv/dv] in
             let [xsv] = xs in
             let [c] = [
              and (or (signum cv = signum dv) (abs cv < abs dv)) 
                      (and ((cv+dv)*qv < av+bv+1) 
                           (av+bv < (cv+dv)*qv + (cv+dv)))] in
             case c of
               True ->
                   cons [qv] (ratTrans [cv] [dv] [av-qv*cv] [bv-qv*dv] [xsv])
             | False ->
                   let [xv] = head [xsv] in
                    ratTrans [bv] [av+xv*bv] [dv] [cv+xv*dv] (tail [xsv])
   )))

letu toDigits = 
   fix ((fun toDigits ->
          fun l ->
            let [lid] = l in
            cons (head [lid]) (toDigits (ratTrans [10] [0] [0] [1] (tail [lid])))))

letu e = (toDigits eContFrac)

letu ttt = printlist e [500]
letu ttu = printlist eContFrac [2100]

type three<'a> = One of 'a | Two of unit | Three of 'a*'a

letu xxx = fun x ->
   let [v] = x in
   case v of
     One(a) -> [a]
   | Two -> [1]
   | Three(p) -> [let (x,y)=p in x]

letu yyy = let [a] = xxx [Three(3,4)] in [print a]
