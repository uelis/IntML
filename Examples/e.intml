mutable type ref<'a> = Ref of 'a 

letu reftest =
  [ let r = Ref 5 in
    let u = (r :=<ref> Ref 12) in
      case r of 
        Ref(x) -> print x ]

type list<'a> = Nil of unit | Cons of 'a * list<'a>

letw fixw = fun x ->
  case x of 
    Inl(lx) -> 
      let (l,x) = lx in
        (case x of
           Inl(bq) ->
             let (b,q) = bq in
               Inl(Cons(b,l), Inr(q))
         | Inr(a) ->
             (delete l of (* TODO *)
                Nil -> Inr(a)
              | Cons(hdtl) ->
                 let (hd, tl) = hdtl in
                   Inl(tl, Inl(hd, a))))
  | Inr(q) -> 
     Inl(Nil, Inr(q))

letu fix = hack fixw
 as {list<'b>}({'b}'a --o 'a) --o 'a

mutable type stream<'a> = 
        Susp of cont<cont<stream<'a>>>
      | SCons of (cont<cont<'a>> + int) * stream<'a>

(* Invariante: Wenn man Inl(k) einmal forced, dann kommt nicht wieder
 * eine Liste der Form Inl(...) heraus *)
letu cons : [int] --> [stream<int>] --> [stream<int>] =  
  (fun x -> fun xs ->
    let [xk] = grabc(x) in
    let [xsk] = grabc(xs) in
    let [id] = 
           [ SCons(Inl(xk), Susp(xsk)) ] in
        [id])

letu ft = 
  fun l -> 
    let [lid] = l in
    case lid of
      Susp(thunk) -> 
        let [v] = callc thunk in
        let [u] = [ lid :=<stream> v] in
          [lid]
    | SCons(v) -> [lid]

letu head =
  fun l -> 
    let [lid] = ft l in
    case lid of
      Susp(thunk) -> 
        [let x=0 loop Inr(x)]
    | SCons(ht) ->
        case let (h,t) = ht in h of
          Inl(k) -> 
            let [v] = callc k in
            let [u] = [  let (h,t) = ht in
                         lid :=<stream> SCons(Inr(v), t) ] in
              [v]
        | Inr(v) -> 
              [v]

letu tail =
  fun l -> 
    let [lid] = ft l in
    case lid of
      Susp(thunk) -> 
        [let x=0 loop Inr(x)]
    | SCons(ht) ->
        [let (h,t) = ht in t]

letu thunk =
  fun l -> 
    (* Invariante erhalten *)
    let [thunk] =  grabc (ft l) in
      [ Susp(thunk) ]
    
letu zipWith = fun f -> 
  fix (fun zw -> fun l1 -> fun l2 ->
     let [v1] = l1 in
     let [v2] = l2 in
       cons (f (head [v1]) (head [v2])) (zw (tail [v1]) (tail [v2])))

letu fib =
  (fix ( (fun f ->
       let [v] = thunk f in
       cons [0] (cons [1] (zipWith (fun x -> fun y -> 
                                      let [xv] = x in
                                      let [yv] = y in [xv+yv])
                               [v] (tail [v])) ))))

(* loop im Compiler!
letu cycle =
  (fix (fun cycle -> fun n -> cons [1] (cycle n)))
*)

letu cycle =
  (fix (fun cycle -> cons [1] cycle))

letu printlist =
  fix (fun printlist -> 
         fun l -> fun i -> 
           let [iv] = i in
           if iv = 0 then [()] 
             else
                let [lid] = l in 
                let [u] = let [xv] = head [lid] in [print xv] in
          (*      let [u] = [if iv + 1 < jv then print ", " else ()] in *)
                  printlist (tail [lid]) [iv - 1]) 

letu aux =
  fix (fun aux -> fun n ->
           let [nv] = n in
             cons [1] (cons [nv] (cons [1] (aux [nv + 2]))))

letu eContFrac =  (cons [2] (aux [2]))

letw signum = fun x -> if 0 < x then 1 else if x = 0 then 0 else 0-1
letw abs = fun x -> if 0 < x then x else 0-x

letw not : bool -> bool =
  fun x -> case x of True -> False | False -> True
letw and : bool -> bool -> bool =
  fun x -> fun y ->
    case x of True -> y | False -> False
letw or = fun (x : bool) -> fun (y : bool) ->
  case x of True -> True | False -> y

letu andalso : [bool] --> [bool] --> [bool] =
  fun x -> fun y ->
    let [b] = x in
      if b then y else [False]

letu orelse : [bool] --> [bool] --> [bool] =
  fun x -> fun y ->
    let [b] = x in
      if b then [True] else y

letu ratTrans =
   (fix ((fun ratTrans ->
          fun a -> fun b -> fun c -> fun d -> fun xs ->
             let [av] = a in
             let [bv] = b in
             let [cv] = c in
             let [dv] = d in
             let [xsv] = xs in
             let [c] = 
               andalso 
                 (orelse [signum cv = signum dv] [abs cv < abs dv])
                 (andalso [(cv+dv)*(bv/dv) < av+bv+1]
                          [av+bv < (cv+dv)*(bv/dv) + (cv+dv)]) in
             if c then
                cons [bv/dv] (ratTrans [cv] [dv] [av-(bv/dv)*cv] [bv-(bv/dv)*dv] [xsv])
             else 
                let [xv] = head [xsv] in
                 ratTrans [bv] [av+xv*bv] [dv] [cv+xv*dv] (tail [xsv])
   )))

letu toDigits = 
   fix ((fun toDigits ->
          fun l ->
            let [lid] = l in
            cons (head [lid]) (toDigits (ratTrans [10] [0] [0] [1] (tail [lid])))))

letu e = (toDigits eContFrac)

letu ttt = printlist e [20]
letu ttu = printlist eContFrac [2100]

type three<'a> = One of 'a | Two of unit | Three of 'a*'a

letu xxx = fun x ->
   let [v] = x in
   case v of
     One(a) -> [a]
   | Two -> [1]
   | Three(p) -> [let (x,y)=p in x]

letu yyy = let [a] = xxx [Three(3,4)] in [print a]

