letw return = fun x -> inl(x)
letw continue = fun x -> inr(x)

letw pi1 = fun x -> let <x1, x2> = x in x1
letw pi2 = fun x -> let <x1, x2> = x in x2

letw true : 2 = inl(<>)
letw false : 2 = inr(<>)
letw not : 2 -> 2 =
  fun x -> if x then false else true
letw and : 2 -> 2 -> 2 = 
  fun x -> fun y ->
    if x then (if y then true else false) else false
letw or = fun (x : 2) -> fun (y : 2) ->
  if x then true else y
letw pi1 = fun x -> let <x1, x2> = x in x1
letw pi2 = fun x -> let <x1, x2> = x in x2

(* working class addition *)
letw add : 'a -> int -> 'a = 
  fun x -> fun y ->
    let z = <x, y> 
    loop
      let <x1, y1> = z in
      if or (y1 = 0) ((x1 + 1) = x1) then return(x1)
                 else continue(<x1 + 1, y1 - 1>)

letw mul : int -> int -> int = 
  fun x -> fun y ->
    let z = <0, y> 
    loop
      let <x1, y1> = z in
      if y1 = 0 then return(x1)
                 else continue(<add x x1, y1 - 1>)

(* working class subtraction *)
letw sub : int -> int -> int = 
  fun x -> fun y ->
    let z = <x, y> 
    loop
      let <x1, y1> = z in
      if or (x1 = 0) (y1 = 0) then return(x1)
                 else continue(<x1 - 1, y1 - 1>)

letw leq : 'a -> 'b -> 2 =
  fun x -> fun y ->
    let z = <x, y>
    loop
      let <x', y'> = z in
      if y' = 0 then
         if x' = 0 then return true else return false
      else 
         if x' = 0 then return true else continue <x' - 1, y' - 1>

letw divmod : 'a -> 'b -> 'a * 'a = 
  fun x -> fun y ->
    let z = <x, 0>
    loop
      let <x', d> = z in
      if leq x' y then 
         if leq y x' then return <d + 1, 0> else return <d, x'>
      else continue <sub x' y, d + 1>

(* Print values of 'a as decimal numbers.
 * (uses function types!) *)
letw print_dec : 'a -> 1 =
   let ten = 10 in
   let print_upto10 =
      fun (x : 'a) ->
        if x = 0 then print "0" 
        else if x = 1 then print "1" 
        else if x = 2 then print "2" 
        else if x = 3 then print "3" 
        else if x = 4 then print "4" 
        else if x = 5 then print "5" 
        else if x = 6 then print "6" 
        else if x = 7 then print "7" 
        else if x = 8 then print "8" 
        else print "9" in
   fun x -> 
      let p = <x, fun u -> u>
      loop 
         let <z, f> = p in
         let <d, m> = divmod z ten in
         let f' = fun u -> (let z = print_upto10 m in f u) in
           if d = 0 then 
             (let z = f' <> in  return <>)
           else 
             continue <d, f'>

letw fixw = fun x ->
  case x of 
    inl(lx) -> 
      let <l,x> = lx in
        case x of
          inl(bq) ->
            let <b,q> = bq in
              inl(<fold<'c.1+'b*'c> inr(<b,l>), inr(q)>)
        | inr(a) ->
            case unfold<'c.1+'b*'c> l of
              inl(nl) -> 
                 inr(a)
            | inr(cns) ->
               let <hd, tl> = cns in
                 inl(<tl, inl(<hd, a>)>)
  | inr(q) -> 
     inl(<fold<'c.1+'b*'c> inl(<>), inr(q)>)

letu fix = hack fixw
 as {mu 'c. 1 + 'b*'c}({'b}'a --o 'a) --o 'a

letu succu =
  fun x -> let [v] = x in [v + 1]

letu addu : ['a] --> ['b] --> ['a] =
  fun x ->
  fix (fun (add : ['b] --> ['a]) -> fun (y : ['b]) ->
    let [vy] = y in
    case vy = 0 of
      inl(true) -> 
       x
    | inr(false) -> 
       succu (add [vy - 1])
  )

letu fib2 : [int] --> [int] = 
  fix (fun f -> fun x ->
    let [v] = x in
      case or (v = 0) (v = 1) of 
        inl(true) ->
          [1]
      | inr(false) ->
          copy f as f1, f2 in
          addu (f1 [v - 1]) (f2 [v - 2]))

letu mulu : [int] --> [int] --> [int] =
  fun x ->
  fix (fun (mul : [int] --> [int]) -> fun (y : [int]) ->
    let [vy] = y in
    case vy = 0 of
      inl(true) -> [0]
    | inr(false) -> 
       addu x (mul [vy - 1])
  )

letu fact2 : [int] --> [int] = 
  fix (fun f -> fun x ->
    let [v] = x in
      case v = 0 of 
        inl(true) ->
          [1]
      | inr(false) ->
          mulu [v] (f [v-1]))

letu f : (['a] --> ['a]) --> ['a] --> ['a] = 
  fun f -> fun x ->
    let [v] = x in
      case leq v 1 of 
        inl(true) ->
          [1]
      | inr(false) ->
          copy f as f1, f2 in
          let [w1] = f1 [v-1] in
          let [w2] = f2 [v-2] in
            [add w1 w2]

letu fib : [int] --> [int] = fix f

letu g : (['a] --> ['a]) --> ['a] --> ['a] = 
  fun f -> fun x ->
    let [v] = x in
      case v = 0 of 
        inl(true) ->
          [1]
      | inr(false) ->
          let [w1] = f [v-1] in
            [mul v w1]

letu fact : [int] --> [int] = fix g

letu g_tr : (['a] --> ['a] --> ['a]) --> ['a] --> ['a] --> ['a] = 
  fun f -> fun x -> fun accu ->
    let [v] = x in
    let [acc] = accu in
      case v = 0 of 
        inl(true) ->
          [acc]
      | inr(false) ->
          f [v-1] [mul v acc]

letw t = let [x] = fib [0] in let z = print " " in print x
letw t = let [x] = fib [1] in let z = print " " in print x
letw t = let [x] = fib [2] in let z = print " " in print x
letw t = let [x] = fib [3] in let z = print " " in print x
letw t = let [x] = fib [4] in let z = print " " in print x
letw t = let [x] = fib [5] in let z = print " " in print x
letw t = let [x] = fib [6] in let z = print " " in print x
letw t = let [x] = fib [7] in let z = print " " in print x

letw t = let [x] = fib2 [0] in let z = print " " in print_dec x
letw t = let [x] = fib2 [1] in let z = print " " in print_dec x
letw t = let [x] = fib2 [2] in let z = print " " in print_dec x
letw t = let [x] = fib2 [3] in let z = print " " in print_dec x
letw t = let [x] = fib2 [4] in let z = print " " in print_dec x
letw t = let [x] = fib2 [5] in let z = print " " in print_dec x
letw t = let [x] = fib2 [6] in let z = print " " in print_dec x
letw t = let [x] = fib2 [7] in let z = print " " in print_dec x
letw t = let [x] = fib2 [8] in let z = print " " in print_dec x

letw t = let [x] = fact [0] in let z = print " " in print_dec x
letw t = let [x] = fact [1] in let z = print " " in print_dec x
letw t = let [x] = fact [2] in let z = print " " in print_dec x
letw t = let [x] = fact [3] in let z = print " " in print_dec x
letw t = let [x] = fact [4] in let z = print " " in print_dec x
letw t = let [x] = fact [5] in let z = print " " in print_dec x


letu tu = let [x] = fact2 [7] in [print x]
