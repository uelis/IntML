Installation
============

Dependencies

The compilation to LLVM uses the OCaml LLVM bindings. These
can be installed as follows:

* Ubuntu:
  
  apt-get install ocaml-findlib llvm-ocaml-dev

* Using the OCaml Package Manager (OPAM)
  (OPAM can be obtained from http://http://opam.ocamlpro.com)

  opam install ocamlfind llvm


Basic Usage
===========

 An intml-file consists of definition of the form:
 
   letw f = working_class_term
   letw g = upper_class_terms
 
 See the files in directory Examples/ for syntax and format.
 
 A file containing such definitions can be type-checked using
 
   ./intml.native file.intml
 
 The intml-interpreter is then in interactive mode and can be 
 used to evaluate terms.


Interactive Mode
----------------

Working Class Terms
-------------------

 Working class terms can be evaluated directly.

  # Inl()
  : unit + 'a
 
  Inl()

 They can be defined using letw.

  # letw pi1 = fun x -> let (x1,x2) = x in x1
  pi1 :w 'a * 'b -> 'a
  
  # pi1 (Inl(), Inr())
  : unit + 'a
  
  = Inl()
  
Upper Class Terms
-----------------

 Upper class terms can be defined using letu.

  # letu d = fun f -> fun x -> let [v]=x in f [v] [v]
  d :u (['a] --> ['a] --> ['b]) --> ['a] --o ['b]

 However, they cannot be evaluated directly, as can working 
 class terms.

 For the evaluation of upper class terms one has the following 
 options:

 * Terms f of type [A] can be evaluated using the working-class 
   construct let [x] = f in x.

    # let [x] = d (fun x -> fun y -> x) [Inl()] in x
    : unit + 'a
 
    = Inl()
 
 * The toplevel gives access to the circuit corresponding to any
   working class term. This is available using the #circuit 
   directive.

   The directive 
     #circuit (upper class term)
   displays the type of the circuit for the upper class term.
   
   The directive
     #circuit (upper class term) (working class term)
   feeds the given working class term to the circuit for the
   upper class term and computes the output from the circuit.

   Example:

    # #circuit d
    : 'a * unit * ('b * unit + ('c * unit + 'd)) + (unit * 'a + unit) ->
      'a * unit * ('b * 'a + ('c * 'a + unit)) + (unit * unit + 'd)

    = functional value

   The circuit may thus be sent messages of type 
   'a * unit * ('b * unit + ('c * unit + 'd)) + (unit * 'a + unit)
   and it may answer with messages of type
   'a * unit * ('b  * 'a + ('c * 'a + unit)) + (unit * unit + 'd)

   For example, the circuit for d answers the query Inr(Inr()) 
   with Inr(Inl((), ())).

    # #circuit d Inr(Inr())
    : 'a * unit * ('b * 'a + ('c * 'a + unit)) + (unit * unit + 'd)
 
    = Inr(Inl((), ()))
   
   In the #circuit directive it is also possible to use 
   complex upper class terms

    # #circuit (fun x->let (y,z) = x in let [v]=y in [(v,v(])
    : unit * unit * ('a + 'b) + unit -> 
      unit * unit * (unit + 'c) + 'a * 'a
 
    = functional value

 * Animations for circuit computation can be generated using
   the #sim directive. This generates a pdf file with an animation
   of circuit computation. It needs graphviz (dot) and pdftk.

   For example 
     
     # #sim d Inr(Inr()) 

   generates a file circuit.sim.pdf in the current directory, which
   shows the first 10 steps of the computation of cirucit d with input
   Inr(Inr()). 

   The number of steps can be changed as follows:
    
    # #simlength 20
